# 模拟

## 基础模拟

用简单的一句话概括模拟题，就是“使用计算机来朴素模拟某一机械过程的行为”，他往往具有以下两个特点：

1. 模拟题仅需要考虑“实现该行为”，一般不涉及过度复杂的思维与算法知识
2. 相比于其他算法题，模拟题的代码量更大，细节更多，更加考验选手的工程能力

话不多说，我们来观察一个模拟题：

> [洛谷P1563 NOIP2016 提高组 D1T1 玩具谜题](https://www.luogu.com.cn/problem/P1563)
>
> 题目描述：
>
> 小南有一套可爱的玩具小人, 它们各有不同的职业。
>
> 有一天, 这些玩具小人把小南的眼镜藏了起来。 小南发现玩具小人们围成了一个圈,它们有的面朝圈内,有的面朝圈外。如下图:
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/0u7em9pi.png) 
>
> 这时 singer 告诉小南一个谜題: “眼镜藏在我左数第 $3$ 个玩具小人的右数第 $1$ 个玩具小人的左数第 $2$ 个玩具小人那里。 ”
>
> 小南发现, 这个谜题中玩具小人的朝向非常关键, 因为朝内和朝外的玩具小人的左右方向是相反的: 面朝圈内的玩具小人, 它的左边是顺时针方向, 右边是逆时针方向; 而面向圈外的玩具小人, 它的左边是逆时针方向, 右边是顺时针方向。
>
> 小南一边艰难地辨认着玩具小人, 一边数着:
>
> singer 朝内, 左数第 $3$ 个是 archer。
>
> archer 朝外,右数第 $1$ 个是 thinker 。
>
> thinker 朝外, 左数第 $2$ 个是 writer。
>
> 所以眼镜藏在 writer 这里!
>
> 虽然成功找回了眼镜, 但小南并没有放心。 如果下次有更多的玩具小人藏他的眼镜, 或是谜题的长度更长, 他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。 这样的谜題具体可以描述为:
>
> 有 $n$ 个玩具小人围成一圈, 已知它们的职业和朝向。现在第 $1$ 个玩具小人告诉小南一个包含 $m$ 条指令的谜題, 其中第 $z$ 条指令形如“左数/右数第 $s$,个玩具小人”。 你需要输出依次数完这些指令后,到达的玩具小人的职业。
>
> 输入格式：
>
> 输入的第一行包含两个正整数 $n,m$，表示玩具小人的个数和指令的条数。
>
> 接下来 $n$ 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 $0$ 表示朝向圈内，$1$ 表示朝向圈外。 保证不会出现其他的数。字符串长度不超过 $10$ 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。
>
> 接下来 $m$ 行，其中第 $i$ 行包含两个整数 $a_i,s_i$，表示第 $i$ 条指令。若 $a_i=0$，表示向左数 $s_i$ 个人；若 $a_i=1$，表示向右数 $s_i$ 个人。 保证 $a_i$ 不会出现其他的数，$1 \le s_i < n$。
>
> 输出格式：
>
> 输出一个字符串，表示从第一个读入的小人开始，依次数完 $m$ 条指令后到达的小人的职业。
>

题目很长，我们简单概括一下：我们需要在程序中建模出一个环，并模拟指针的顺时针/逆时针转动，最终输出被指到的人的职业。

那我们使用结构体来存储小人的信息，数组来模拟一个环，随后通过数学方式或一步步移动的方式来模拟指针的移动即可。这里给出一份可以AC的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
// 结构体，存储每个人的朝向和姓名
struct people {
    int f;
    string name;
} p[N];
int main() {
    int n, m;
    cin >> n >> m;
    // 下标从0开始
    for (int i = 0; i < n; ++i)
        cin >> p[i].f >> p[i].name;
    int now = 0;
    while (m--) {
        int d, s;
        cin >> d >> s;
        //根据朝向和左右指令，总和确认是顺时针还是逆时针
        int r = d ^ p[now].f;
        if (r)
            now = (now + s) % n;
        else
            now = (now - s + n) % n;
    }
    cout << p[now].name << endl;
    return 0;
}
```

## 复杂模拟

一般来说，算法竞赛中的模拟题不会像上面这么简单。一旦它们在非签到题的位置出现，其题面长度和代码复杂性都会远超想象（先不管[猪国杀](https://www.luogu.com.cn/problem/P2482)这种逆天了，单是CSP第三题这种难度的题就足够吃一壶了）。

这种题目极度考验选手的基本功，难以短时间内进行学习、获得提升。我在这里给出一些建议：

* 编写前在草稿纸上大体评估一下流程
* 尝试将整个程序分成若干模块，自顶向下逐步解决
* 对于常用代码，建议提取出来以便复用
* 如果整体难以完成，建议退而求其次，尝试实现简单部分（有部分分的话）
* 多写注释，别把自己绕进去了
* 模拟题一般对时间限制不高，建议多使用系统库内自带的算法/数据结构而非手写

## 高精度

在C/C++中，int只能存下 $2^{31}$ 以内的整数，而更大的 long long 也只能存储 $2^{63}$ 以内的整数。如果你的程序需要运算远大于这个规模的数据，那么你可能需要手动模拟加减和乘法，从而实现“高精度运算”。（严格来讲，我觉得“大整数运算”更符合这个名字）

不过，我个人认为这个知识点并非过于重要，因为：

* 当前的算法竞赛中，如果运算结果会远大于限制，出题人往往会倾向于让选手进行“取模/取余”操作（出题人也不想搁那写高精度）
* 高精度算法本身的复杂度难以预估，会影响题目本身算法/数据结构的考察
* Java/Python支持原生的大整数运算，实在不行就用它两来算得了
# 枚举

## 枚举的概念

我们考虑这样一个问题：鸡兔同笼，有 $n$ 个头 $m$ 只脚，问鸡和兔分别有几只？

根据初中知识，我们不难推导出二元一次方程组并求解：
$$
\begin{cases}
x+y=n\\
2x+4y=m
\end{cases}
$$
不过，如果我们使用计算机，可能会写出另一种更加暴力的算法，而非花费精力去教它解方程组：

```cpp
for (int x = 0; x <= n; ++x)
    for (int y = 0; y <= n; ++y)
        if (x + y == n && 2 * x + 4 * y == m)
            printf("chicken:%d rabbit:%d\n", x, y);
```

作为电子设备，计算机天生适合大批简单且繁复的重复运算，运算速度百万倍于人脑，我们恰好可以使用这个特性，直接枚举所有可能的解，并验证是否合法（打个比方，电脑可以在1s内枚举出所有的八位纯数字密码）。即使算法与数据结构发展到今天，暴力枚举往往还是很多问题的综合最优解。

我们来看这样一个题目：

> [洛谷P3392 涂国旗](https://www.luogu.com.cn/problem/P3392)
>
> 给定一个 $n$ 行 $m$ 列的矩阵。每个格子的颜色可能是红蓝白之一。
>
> 现在，我们打算把矩阵重新涂色，变成一个国旗的形式（最上方若干行为白色，跟着中间若干行蓝色，生下来倒数几行都是红色）。请问如何涂色，可以使得被重新涂色的格子数量最少？
>
> $n,m\leq 50$

我们尝试描述以下矩阵最后的状态，可以发现：使用一个二元组 $(l,r)$ 是最简洁的（$[1,l-1]$ 行为白色，$[l,r]$ 行为蓝色，$[r+1,n]$ 为红色）。那么，我们不妨直接枚举所有可能的状态（$1<l\leq r<n$），随后对于每种状态都检查一下需要重新涂几个颜色。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 60;
//t[i]代表的3元数组代表第i行三种颜色的数量
int n, m, t[60][3];
int ans = 1e9 + 10;
int cal(int l, int r) {
    int res = 0;
    for (int i = 1; i < l; ++i)
        res += t[i][1] + t[i][2]; //涂成白色，那么就需要把红蓝的格子涂掉，下面同理
    for (int i = l; i <= r; ++i)
        res += t[i][0] + t[i][2];
    for (int i = r + 1; i <= n; ++i)
        res += t[i][0] + t[i][1];
    return res;
}
int main() {
    // 读入
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        string s;
        cin >> s;
        for (int j = 0; j < m; ++j) {
            if (s[j] == 'W') t[i][0]++;
            else if (s[j] == 'B') t[i][1]++;
            else t[i][2]++;
        }
    }
    for (int l = 2; l <= n - 1; ++l)
        for (int r = n - 1; r >= l; --r)
            ans = min(ans, cal(l, r));
    cout << ans << endl;
    return 0;
}
```

## 枚举的优化

当然，电脑运算的速度不可能超的过问题增长的速度，因此我们往往需要对问题进行分析，尝试缩小解空间，减少所需要枚举的内容，优化枚举顺序，从而提升程序的运行效率。

我们以上面的鸡兔同笼为例，就算是复杂度很高的枚举，我们真的需要双重循环吗？

不难注意到，当我们枚举出鸡的数量 $x$，我们自然就能推导出 $y$ 的值，而非反复枚举后傻傻的验证：

```cpp
for (int x = 0; x <= n; ++x) {
    int y = n - x;
    if (2 * x + 4 * y == m)
        printf("chicken:%d rabbit:%d\n", x, y);
}
```

相比于上面的代码，它通过减少无用状态的枚举，大幅减少了运算时间（从大约 $n^2$ 次检查减少到了 $n$ 次）。

## 枚举的其他形式

除了普通的循环枚举，我们还往往用到搜索枚举和子集枚举，我们会在下面的教程中提到。


# 二分

## 二分的概念

相信大家以前多多少少都玩过“猜数字”这个游戏：

> 小明在心中想一个范围在 $[1,1000]$ 之内的数字，让小红进行猜测。每当小红猜测某个数的时候，小明必须从“大了，小了，相等”中选出一个作为回答。请问，小红应该采取什么策略，才能用最少的次数猜出这个数？

那么，小红应该设立一个初始区间 $[1,1000]$（也就是，这个答案一定在这个区间里面）。随后，小红每次都应该取区间的中间数 $x$，并将这个数告诉小明，从他那里得到一个答案：

1. 大了：那么将 $x-1$ 作为新区间的右端点（因为 $x$ 已经大了，那么原区间所有大于 $x$ 的数字同样需要被排除）
2. 小了：那么将 $x+1$ 作为新区间的左端点（因为 $x$ 已经小了，那么原区间所有小于 $x$ 的数字同样需要被排除）
3. 相等：游戏结束

可以看到，对于一个大小为 $n$ 的答案备选集合，我们使用这种方式，每次都可以排除集合内一半的答案，只需要约 $\log n$ 次即可得到结果。

对于这种每次取中间值，并根据判断结果排除掉一半备选答案的算法，我们称之为二分法。二分法的核心在于**单调性**（如上一题中，数的大小关系就是明显的二分性）。

## 在有序数组中查找值

给定一个有序数组 $\{a_n\}$，尝试使用一个高效的算法求出数组中第一个大于等于 $x$ 的数（的下标）。

```cpp
int l = 1, r = n + 1;
while (l < r) {
    // 右移是向下取整（除以2是向0取整），能够适用于包含负数的场景
    int mid = (l + r) >> 1;
    if (a[mid] >= x) r = mid;
    else l = mid + 1;
}
```

如果要求出最后一个小于等于 $x$ 的数（的下标）呢？

```cpp
int l = 1 - 1, r = n;
while (l < r) {
    int mid = (l + r + 1) >> 1;
    if (a[mid] <= x) l = mid;
    else r = mid;
}
```

上述两个循环，均在 $l=r$ 时终止，此时 $l$ 停留的位置就是最终答案。

二分的思路很简单，但是细节相当之多，这里提供了一种较为合适的写法，根据二分方式来自行决定（需要 `r=mid,l=mid+1`就第一个板子，反之则第二个）。虽然这种方式有两种形式，但是形式很优美、二分结束条件恰好对应答案所在值、答案始终处于二分区间内、很自然的应对无解情况（第一种情况是右端点加一，第二种是左端点减一）。

## 二分答案

我们来看这个问题：

> [洛谷P1873 [COCI 2011/2012 #5] EKO / 砍树](https://www.luogu.com.cn/problem/P1873)
>
> 树林里面有 $n$ 个数，其中第 $i$ 颗树的高度是 $a_i$ 米。
>
> 伐木工人想要砍下至少 $M$ 米的木材，因此他决定选取一个高度 $h$，将每棵树高度超过 $h$ 的部分砍下来（没超过的话就不砍了）。
>
> 问，应该如何选择高度 $h$，使得在达到要求（砍下至少 $M$ 米木材）的情况下尽可能大。
>
> $1\leq n\leq 10^6,1 \leq M\leq 2*10^9,1\leq a_i\leq 10^9,\sum a_i>M$

朴素的暴力做法是，我们从小到大枚举 $h$，如果发现某个时刻可以让 $h$ 满足要求，但 $h+1$ 不满足，那么答案就是 $h$。

那么问题来了，为什么 $h$ 满足要求、但 $h+1$ 不满足时，答案就是 $h$ 呢？

我们意识到，如果高度为 $h$ 时能够砍下 $x$ 米的木材，那么当高度提高时，砍下的木材数量就一定变少。换言之，当 $h$ 满足而 $h+1$ 不满足的时候，任何大于 $h$ 的高度将都不符合要求。

事实上，我们尝试用 $f(h)$ 来表示高度为 $h$ 时砍下的木材量，那么不难发现 $f(h)$ 是一个单调不增的函数。因此，问题似乎就转变成了：在这个单调函数上查找令函数值大于等于 $M$ 的最大 $h$。显然，我们可以二分它，而函数值则可以 $O(n)$ 的计算。因此，我们能够在 $O(n\log 10^9)$ 的复杂度内解决这个问题。

```cpp
#include<bits/stdc++.h>
using namespace std;
using LL = long long;
const int N = 1000010;
int n;
LL m, a[N];
LL f(int h) {
    LL res = 0;
    for (int i = 1; i <= n; ++i)
        res += max(0LL, a[i] - h);
    return res;
}
int main() {
    scanf("%d%lld", &n, &m);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    int l = 0, r = 1e9 + 10;
    while (l < r) {
        int mid = (l + r + 1) >> 1;
        if (f(mid) >= m) l = mid;
        else r = mid - 1;
    }
    printf("%d\n", l);
    return 0;
}
```

此类问题的核心在于，要敏锐的捕捉到题目所蕴含的单调性质，将问题从“直接求解”转变为“二分+判定”。

如果你短时间内难以敏锐掌握，那么可以熟记这两个关键词：“最大值最小”和“最小值最大”。如果题目中包含这两个信息之一，那么大概率就是二分法。

## 习题

* [P2249 【深基13.例1】查找](https://www.luogu.com.cn/problem/P2249)
* [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)
* [P2678 【NOIP2015 提高组】 跳石头](https://www.luogu.com.cn/problem/P2678)

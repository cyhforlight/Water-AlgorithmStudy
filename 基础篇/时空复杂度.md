# 时空复杂度

## 时间复杂度

### 时间复杂度简介

不同电脑的运算速度并不相同，因此我们一般使用“基本操作次数”（加减乘除、判断、赋值）的数量来衡量算法的时间复杂度。

对于一个算法，我们需要考虑数据规模的大小（例如一个数列的长度、一个图的点数和边数等），越大的数据规模往往需要花费越长的时间。相比于具体的数字，我们一般使用由数据规模变量所构成的一个表达式来评估算法用时随规模增长而上升的速率，即**时间复杂度**。

时间复杂度一般考虑“最坏复杂度”和“平均复杂度”，不过大部分情况下我们不做区分。

我们不讨论渐近复杂度的严格定义，只简略讨论一下它在算法竞赛中的基础应用。

### 基于循环的时间复杂度

```cpp
for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= n; ++j)
        ans += i * j;
```

对于这段程序，我们发现核心语句被执行了 $n^2$ 次左右，因此它的复杂度是 $O(n^2)$。对于这段程序，我们只需要将 $n$ 的具体值代入表达式，即可大致评估出它的基本操作次数的数量。

当然，严格意义上的“基本操作次数”不止这么多（循环变量的增加、判断语句什么的），但是这些只是常数，无非是 $2n^2,3n^2$ 的区别，而不影响整体复杂度的增长趋势。

一个题目的复杂度函数可能会包含若干个项，但我们一般只保留增长最快的若干项（在讨论的数据范围内），因为他们会随着数据规模的增长而逐渐占据主导，例如下面这个程序片段：

```cpp
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j)
        for (int k = 1; k <= n; ++k)
            ans += x;
    for (int j = 1; j <= 3; ++j)
        for (int k = 1; k <= n; ++k)
            ans += y;
    
}
```

这段程序中，核心语句被执行了约 $n^3+3n^2$ 次，但是复杂度我们只保留 $O(n^3)$，因为前者随着 $n$ 的增大而逐步占据主导。

函数增长率的计算属于数学范畴，我们一般只需要了解：阶乘>指数>多项式>对数>常数即可。实在不行，代入题目数据自行算一下即可。

### 基于递归的时间复杂度

```cpp
int f(int l, int r) {
    if (l == r) return;
    int mid = (l + r) / 2;
    f(l, mid);
    f(l, mid + 1);
    for (int i = l; i <= r; ++i)
        ans += i;
}
f(1, n);
```

该函数的复杂度规模为 $T(n)=2T(\frac{n}{2})+O(n)=O(n\log n)$，大家可以画一个递归树来模拟一下这套流程。这个递推式是算法竞赛中最为常见的，需要熟练掌握。

对于更加复杂的递推式，我们可以根据**主定理**来推算

### 数据规模与时间复杂度的关系

现代计算机一般每秒支持 $2*10^8$ 级别的运算，因此对于不同的数据规模，我们需要评估这个算法是否合适（数值代进去看看会不会超过最大运算次数）。

|        数据规模         |            算法            |
| :---------------------: | :------------------------: |
|        $n>10^8$         |      $O(1),O(\log n)$      |
|       $n>2*10^6$        |           $O(n)$           |
|  $10^5\leq n\leq 10^6$  | $O(n\log n),O(n\log ^2 n)$ |
| $5*10^4\leq n\leq 10^5$ |       $O(n\sqrt{n})$       |
| $2*10^3\leq n\leq 10^4$ |          $O(n^2)$          |
|   $200\leq n\leq 500$   |          $O(n^3)$          |
|   $50\leq n\leq 100$    |          $O(n^4)$          |
|       $n\leq 25$        |          $O(2^n)$          |
|       $n\leq 20$        |         $O(n*2^n)$         |
|       $n\leq 11$        |          $O(n!)$           |

## 空间复杂度

### 空间复杂度简介

一般来说，一道题目所允许使用的空间大小是有限的，大约是128MB/256MB左右。

大部分OJ遵循的策略是“使用多少算多少”，但也有很多OJ采取的是“你只要申请了就算占了这么多空间，无论你用没用”。

### 栈与堆

变量定义有两种方式：函数内定义（分配到栈上）和函数外定义（分配到堆上）。栈上的空间很小，因此大型变量/数组等建议在函数外定义，以免出现“栈溢出”。

当然，函数内的malloc/free、new/delete、STL数据结构的空间都是分配在堆上的，那个无所谓。

### 数据规模与空间复杂度

一个int是4字节，因此128MB的空间大约可以分配3000w个int变量。以此为标准，大家就可以大致评估出自己使用的空间有没有超过限制了（一个char是1字节，一个long long是八个）。
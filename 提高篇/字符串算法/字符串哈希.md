# 字符串哈希



## 字符串哈希基础

字符串哈希是一种字符串到数字的映射，考虑到本质上 ASCII 码都是 0 到 127 之间的数来存储，那么我们可以直接将其视为一个 P 进制数来处理即可（一般会取 P 为 131，13131啥的，据说这几个数不容易产生哈希碰撞）。

```cpp
LL getHash(int n, char *str, const LL P = 131, const LL mod = 998244353) {
    LL res = 0;
    for (int i = 0; i < n; ++i)
        res = (res * P + str[i]) % mod;
    return res;
}
```

## O(1) 查询字符串的子串哈希值

书上有原理，本质上和普通数字的哈希差不多，直接贴代码。

（注意：模数一定要在 $10^9$ 范围之内，因为要保证 $mod^2$ 在 LL 的范围之内）

```cpp
#define LL long long
const int N = 1000010;
struct Hash_STL {
    LL P, mod, mul[N], hashcode[N];
    //传入的str字符串，实际字符从下标1开始
    //例如应该scanf("%s",s + 1); 然后传入的是s
    void buildHash(LL _P, LL _mod, int n, char *str) {
        P = _P, mod = _mod;
        mul[0] = 1, hashcode[0] = 0;
        for (int i = 1; i <= n; ++i)
            mul[i] = mul[i - 1] * P % mod;
        for (int i = 1; i <= n; ++i)
            hashcode[i] = (hashcode[i - 1] * P + str[i]) % mod;
    }
    LL query(int l, int r) {
        return (hashcode[r] - hashcode[l - 1] * mul[r - l + 1] % mod + mod) % mod;
    }
};
```

1. 如果时间比较紧，可以用自然溢出代替取模
2. 如果空间比较紧，那可以用快速幂代替预处理，对应的，询问复杂度也变成了 $O(\log n)$

## 哈希碰撞的处理

一般来说，考虑到生成的这个数肯定大的离谱，所以我们会找一个大模数对其取模，不过这也导致了哈希碰撞的可能性，分两类：

1. 模数越小，越容易产生冲突，例如对于 $mod=10^9+7,n=10^6$，碰撞概率将近千分之一，还挺大的、
2. 对于自然溢出，1e9+7，998244353 这些常见的模数，出题人有可能针对构造一些特殊数据，有意使程序出错或者超时（业界好像俗称哈希洪水攻击），这也存在于不少基于哈希的 STL 容器里面，例如 unordered_map 啥的。

针对这种情况，我们有两种策略：

1. 找一个比较冷门的大模数，这样出题人就没法针对构造数据了，不过普通哈希碰撞还是有可能
2. 找多个大模数分别哈希，只有若干个哈希函数对应值均相等时才认为字符串相同

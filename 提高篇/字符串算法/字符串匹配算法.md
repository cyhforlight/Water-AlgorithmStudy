# 字符串匹配算法

## KMP算法

KMP算法通过计算关键词的 border，从而重复利用了匹配中的消息，以避免无效匹配，从而将复杂度从 $O(nm)$ 降到了 $O(n+m)$。

```cpp
//P3375 【模板】KMP字符串匹配
#include<bits/stdc++.h>
using namespace std;
const int N = 1000010;
int n, m;
char a[N], b[N];
int Next[N], f[N];
void getNext() {
    Next[1] = 0;
    for (int i = 2, j = 0; i <= n; ++i) {
        while (j > 0 && a[i] != a[j + 1]) j = Next[j];
        if (a[i] == a[j + 1]) ++j;
        Next[i] = j;
    }
}
void getF() {
    for (int i = 1, j = 0; i <= m; ++i) {
        while (j > 0 && (j == n || (b[i] != a[j + 1]))) j = Next[j];
        if (b[i] == a[j + 1]) ++j;
        f[i] = j;
        if (f[i] == n) {
            printf("%d\n", i - (n - 1));
        }
    }
}
int main()
{
    scanf("%s%s", b + 1, a + 1);
    n = strlen(a + 1), m = strlen(b + 1);
    getNext();
    getF();
    for (int i = 1; i <= n; ++i)
        printf("%d ", Next[i]);
    return 0;
}
```



## AC自动机

AC自动机是一个多匹配的字符串算法（例如给定文本 $t$ 和单词  $a_1,a_2,\cdots,a_n$，匹配各单词出现的次数和位置）。

注意到，KMP算法的匹配是在序列上的，而AC自动机则选择将单词建立成一个 Trie 树，在上面跑匹配。
# 模意义下的运算

## 基本性质

$$
(a+b)\bmod p=(a\bmod p + b \bmod p) \bmod p
\\
(a-b)\bmod p=(a\bmod p - b \bmod p + p) \bmod p
\\
(a*b)\bmod p=(a\bmod p) * (b \bmod p) \bmod p
$$

## 裴蜀定理与 exgcd

裴蜀定理：不定方程 $ax+by=\gcd(a,b)$ 必然存在一组整数解。

至于求解，我们可以采取类似辗转相除法的方式来求得：

```cpp
void exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return;
    }
    exgcd(b, a % b, y, x);
    y -= a / b * x;
}
```

### 求通解

显然，$ax+by=a(x+k\dfrac{b}{d})+b(y-k\dfrac{a}{d})=\gcd(a,b)$，这样我们就可以得到一组通解：$x=x_0+k\dfrac{b}{d},y=y_0-k\dfrac{a}{d}$。

如果方程是 $ax+by=c$ 形式（其中 $c$ 是 $\gcd{a,b}$ 倍数），那么我们直接在原来特定解上面乘上即可，得 $x=x_0\dfrac{c}{d}+k\dfrac{b}{d},y=y_0\dfrac{c}{d}-k\dfrac{a}{d}$。



## 逆元及其运算

我们考虑如何引入除法到模运算中：因为 $a*\frac{1}{a}\equiv1(\bmod p)$，所以我们记 $ax\equiv 1(\bmod p)$ 中的 $x$ 为 $a$ 在 $p$ 意义下的**逆元**，记为 $a^{-1}$。当我们需要进行除法时候，直接乘上这个数的逆元即可。

### 扩展exgcd求逆元

原方程可以理解为 $ax-py=1$，我们对其进行求解，然后找到 $0\leq x<p$ 的一组解即可。

```cpp
int inv(int a, int p) {
    int x, y;
    exgcd(x, p, x, y);
    return x;
}
```

### 费马小定理

费马小定理：当 $p$ 为质数时，且 $a$ 不是 $p$ 的倍数的情况下，$a^{p-1}\equiv 1(\bmod p)$。

那么，我们快速幂计算 $a^{p-2}\bmod p$ 即可。

```cpp
int inv(int x, int p) { return power(x, p - 2, p); }
```

### 线性递推求逆元

该方法可以 $O(n)$ 的求出 $[1,n]$ 内每个数在 $p$ 意义下的逆元。

```cpp
inv[1] = 1;
for (int i = 2; i <= n; ++i)
    inv[i] = p - inv[p % i] * (p / i) % p;
```

### 求阶乘逆元

这在需要快速求组合数的时候很有用，具体可以看组合数那边。

1. 我们直接循环求出 $1!,2!,\cdots,n!$ 的值（对 $p$ 取模）
2. 快速幂求一下 $n!$ 的逆元
3. 根据 $\dfrac{1}{(k-1)!}=\dfrac{k}{k!}$，倒推出 $(n-1)!,(n-2)!,\cdots,2!,1!$ 的逆元。

```cpp
#define LL long long
int n, mod;
LL fact[N], inv[N];
//
fact[0] = 1;
for (int i = 1; i <= n; ++i)
    fact[i] = fact[i - 1] * i % mod;
inv[n] = power(fact[n], mod - 2, mod);
for (int i = n - 1; i >= 0; i--)
    inv[i] = inv[i + 1] * (i + 1) % mod;
```

此外，其实这个方法也可以线性求普通逆元，因为 $\frac{1}{k}=\frac{(k-1)!}{k!}$。

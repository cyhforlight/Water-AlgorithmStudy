# 组合数相关算法



## 组合数公式

$$
C_n^m=\frac{n!}{m!(n-m)!}
\\
C_n^k=\frac{n-k+1}{k}C_n^{k-1}
\\
C_n^0=C_n^n=1,C_n^m=C_{n-1}^{m-1}+C_{n-1}^m
$$

## 基于逆元的组合数求法

需要进行取模的时候，我们可以使用逆元法加速运算， 从而 $O(1)$ 的计算组合数，流程如下：

1. 我们直接循环求出 $1!,2!,\cdots,n!$ 的值（对 $p$ 取模）
2. 快速幂求一下 $n!$ 的逆元
3. 根据 $\dfrac{1}{(k-1)!}=\dfrac{k}{k!}$，倒推出 $(n-1)!,(n-2)!,\cdots,2!,1!$ 的逆元。

```cpp
//逆元法快速求组合数
#define LL long long
const LL mod = 1e9 + 7;
LL fact[N << 1], inv[N << 1];
//快速幂
LL power(LL a, LL b) {
    LL res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        b >>= 1;
        a = a * a % mod;
    }
    return res;
}
//处理n!的逆元
void init(int n) {
    fact[0] = 1;
    for (int i = 1; i <= n; ++i)
        fact[i] = fact[i - 1] * i % mod;
    inv[n] = power(fact[n], mod - 2);
    for (int i = n - 1; i >= 0; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
}
LL C(LL n, LL m) {
    if (m > n) return 0;
    return fact[n] * inv[m] % mod * inv[n - m] % mod;
}
```



## Lucas 定理

Lucas 定理可以用来快速计算组合数的值。

对于给定数字 $m=sp+q,n=tp+r(0\leq q,r <p)$，那么有
$$
C_n^m\bmod p=C_t^sC_r^q\bmod p
$$

> [P3807 【模板】卢卡斯定理/Lucas 定理](https://www.luogu.com.cn/problem/P3807)
>
> 给定整数 $n,m,p$，求出 $C_{n+m}^n\bmod p$。
>
> $1\leq n,m,p\leq 10^5$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int N = 200010;
LL P, f[N];
LL power(LL a, LL b) {
    LL res = 1;
    while (b) {
        if (b & 1) res = res * a % P;
        b >>= 1;
        a = a * a % P;
    }
    return res;
}
LL inv(LL x) { return power(x, P - 2); }
LL C(LL n, LL m) {
    if (m > n) return 0;
    return f[n] * inv(f[m]) % P * inv(f[n - m]) % P;
}
LL Lucas(LL n, LL m) {
    if (!m) return 1;
    return Lucas(n / P, m / P) * C(n % P, m % P) % P;
}
int main()
{
    int T;
    cin >> T;
    while (T--) {
        LL n, m;
        cin >> n >> m >> P;
        f[0] = 1;
        for (int i = 1; i < N; ++i)
            f[i] = f[i - 1] * i % P;
        cout << Lucas(n + m, m) << endl;
    }
    return 0;
}
```


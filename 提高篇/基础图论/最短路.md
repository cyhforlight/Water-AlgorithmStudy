# 最短路算法



## 链式前向星

```cpp
#define LL long long
const int N = 100010, M = 200010 * 2;
int tot = 0, Head[N], Next[M], ver[M];
LL edge[M];
void addEdge(int x, int y, LL z) {
    ver[++tot] = y, edge[tot] = z;
    Next[tot] = Head[x], Head[x] = tot;
}
//多组数据时记得清空数组和tot
void init() {
    memset(Head, 0, sizeof(Head));
    tot = 0;
}
//遍历
for (int i = Head[x]; i; i = Next[i]) {
    int y = ver[i], z = edge[i];
    //(x, y, z)
}
```

网络流里面的前向星，为了能方便处理反向边，下标是从 0 开始的（对边的下标用 1 来异或就可以达到反向边），所以遍历的时候是判断  $i \not= -1$，然后 addEdge 的时候也改成 tot++。



## Dijkstra 算法

Dijkstra 基于贪心算法（一定程度上也是优先队列 BFS？），可以用来处理不含负边权下的图的最短路，在使用堆优化的情况下，复杂度为 $O((n+m)\log n)$。

```cpp
LL dis[N];
void Dijkstra() {
    memset(dis, 0x3f, sizeof(dis));
    dis[1] = 0;
    priority_queue<pair<LL, int>> q;
    q.push(make_pair(0, 1));
    while (!q.empty()) {
        auto now = q.top(); q.pop();
        int x = now.second;
        if (dis[x] != -now.first) continue;
        for (int i = Head[x]; i; i = Next[i]) {
            int y = ver[i]; LL z = edge[i];
            if (dis[y] > dis[x] + z) {
                dis[y] = dis[x] + z;
                q.push(make_pair(-dis[y], y));
            }
        }
    }
}
```



## Bellman-Ford 算法

Dijkstra 在拥有负边权时无法工作，这时我们需要 Bellman-Ford 算法。

如果对于某条边 $(x,y,z)$，满足 $dis_y\leq dis_x+z$，那么这条边满足三角形不等式。当图中所有边都满足三角形不等式时，所得 $dis$ 数组就是所求最短路。

Bellman-Ford 算法基于上述思想，流程如下：

1. 扫描所有边，当 $dis_y>dis_x+z$ 时进行更新
2. 反复操作1，当操作1不再更新某个点时结束

当没有负环时，这一过程将会在 $n-1$ 轮内结束（因为一条最短路径的长度最多为 $n-1$），复杂度为 $O(nm)$。

```cpp
//跑最长路的时候，初始化极小值可以0xc0
memset(dis, 0x3f, sizeof(dis));
dis[1] = 0;
for (int k = 1; k < n; ++k)
    for (int i = 1; i <= m; ++i) {
        int x = u[i], y = v[i], z = w[i];
        dis[y] = min(dis[y], dis[x] + z);
    }
```



## SPFA 算法

对于 Bellman-Ford 算法，我们发现其实迭代那么多次不是必须的（可能若干次迭代完就好了，每次也不需要遍历所有边）。

我们可以开一个队列，先放进去起点，然后从这个点扫描其出边，能更新就更新，并且在其不在队列中的时候将其放进队列。

这被称为 Bellman-Ford 的队列优化算法，国内一般称为 SPFA，其在随机或者偏稀疏图上的复杂度为 $O(km)$，其中 $k$ 是一个比较小的常数。不过因为其本质上是 BF 的优化，所以在特殊构造的数据下依旧有可能被卡回 $O(nm)$，所以在边权没有负，求的东西比较正常的情况下一般来说还是多用 Dijkstra 算法。

```cpp
LL dis[N], vis[N];
queue<int> q;
void SPFA() {
    for (int i = 1; i <= n; ++i) dis[i] = INF;
    memset(vis, 0, sizeof(vis));
    dis[s] = 0, vis[s] = 1, q.push(s);
    while (!q.empty()) {
        int x = q.front(); q.pop();
        vis[x] = 0;
        for (int i = Head[x]; i; i = Next[i]) {
            int y = ver[i];
            LL z = edge[i];
            if (dis[y] > dis[x] + z) {
                dis[y] = dis[x] + z;
                if (!vis[y]) vis[y] = 1, q.push(y);
            }
        }
    }
}
```



## Floyd 算法

### Floyd 基础思想

这个算法基于 DP，可以计算任意两点之间的最短距离，复杂度 $O(n^3)$。

```cpp
for (int k = 1; k <= n; ++k)
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```

### Floyd 动态加点

打个比方，我们现在已经求出了前 $n$ 个点之间的互相最短路，但是现在我们需要加进来第 $n+1$ 个点，那么我们应该怎么做呢？

我们发现，求 $n$ 个点的多源最短路需要在数组上进行 $n^3$ 次操作（如上），而 $n+1$ 个点则是进行 $(n+1)^3$ 次。实际上，这 $(n+1)^3$ 个操作中是有 $n^3$ 个和之前 $n$ 个点的最短路操作重合的，也就是说，我们只需要在前面的基础上加上关于 $n+1$ 点的操作即可。而这操作主要分三类：作为起点，作为终点，作为中转点。我们按照传统 Floyd 的顺序，得到以下增点函数：

```cpp
void addPoint(int x) {
    for (int k = 1; k < x; ++k) {
        for (int i = 1; i < x; ++i)
            a[i][x] = min(a[i][x], a[i][k] + a[k][x]);
        for (int j = 1; j <= x; ++j)
            a[x][j] = min(a[x][j], a[x][k] + a[k][j]);
    }
    for (int i = 1; i <= x; ++i)
        for (int j = 1; j <= x; ++j)
            a[i][j] = min(a[i][j], a[i][x] + a[x][j]);
}
```

当 $x=n+1$ 时，函数进行了 $n(n+n+1)+(n+1)^2=3n^2+3n+1=(n+1)^3-n^3$ 次操作。



## 负环问题

当图中存在负环时，最短路不再存在。不过，我们可以使用 BF 或者 SPFA 来判断负环的存在性。

### Bellman-Ford 算法

有负环的时候，说明某个点可以被一直迭代下去，那么我们直接跑完 BF 之后再迭代一轮，看看哪些点能被继续迭代。

```cpp
//当存在负环时返回true，反之false
bool solve() {
    //...
    //check
    for (int i = 1; i <= m; ++i) {
        int x = u[i], y = v[i], z = w[i];
        if (dis[y] > dis[x] + z) return true;
    }
    return false;
}
```

### SPFA算法

SPFA 判断负环的话，是通过判断某个点的松弛次数或入队次数是否达到 $n$ 来决定的（好像大多数博客都用的前者，但是上次看到有人构造出数据把他卡掉了，所以求稳妥的话还是用入队次数好一些）。



## 差分约束问题

差分约束系统是一种特殊的 N 元一次不等式组，包含 N 个变量 $x_i$ 和 M 个约束条件，每个约束条件都可以表示为两个变量做差，类似 $X_i-X_j\leq c_k$，其中 $c_k$ 是一个常数。我们的目标是找出一组解，使得所有约束条件都符合要求。

我们可以将条件转化为 $X_i\leq X_j+X_k$，有点类似最短路中的松弛条件 $d_y\leq d_x+z$，所以我们可以构造一个有向图，每个变量相当于一个点，条件 $X_i-X_j\leq c_k$ 可以视为一条 $(j,i,c_k)$ 的有向边。

考虑到做差，显然如果解集 $\{x_i\}$ 合法，那么 $\{x_i+c\}$ 同样合法。我们不妨先设一组负数解，即 $x_i\leq 0$，再增加一个 0 号节点 $X_0$，那就多若干类似 $X_i-X_0\leq 0$ 的约束条件，即从 0 到 i 连一条边权为 0 的有向边。

我们以 0 为起点，$d_0=0$，跑一次最短路，得到的数组 $d$ 就是一组解（存在负环则无解）。

如果条件都是 $X_i-X_j\geq c_k$，那我们可以移项变成最短路问题，也可以改为连边 $(j,i,c_k)$，然后图上跑最长路。

（当我们需要 $x_i\leq C$ 时，一般使用最短路模型，从点 0 向每个点连一条长度为 C 的边；相反，如果需要 $x_i\geq C$ 时，一般使用最长路模型）

1. 对于 $x_i-x_j\leq c$ 的模型，可以变为 $x_i\leq x_j+c$，连一条 $(j,i,c)$，跑最短路
2. 对于 $x_i-x_j\geq c$ 的模型，可以变为 $x_i\geq x_j+c$，连一条 $(j,i,c)$，跑最长路

注意：这种不小于/不大于的不等关系可以扩展到等于和严格大于/小于：
$$
x=y\rightarrow x\leq y, x\geq y\\
x>y\rightarrow x\geq y+1\\
x<y\rightarrow x+1\leq y
$$

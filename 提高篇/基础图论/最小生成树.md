# 最小生成树



## Kruskal 算法

对边从小到大排序，然后贪心选择（全流程中避免图中出现环），最后得到最小生成树（林）。

我们先排序，然后并查集维护图连通性，复杂度 $O(m\log m)$。

```cpp
struct Edge {
    int x, y, v;
    bool operator < (const Edge &rhs) const {
        return v < rhs.v;
    }
};
//认定这个图一定有一个生成树
LL Kruskal(vector<Edge> edge) {
    LL res = 0;
    sort(edge.begin(), edge.end());
    for (Edge e : edge) {
        int x = find(e.x), y = find(e.y);
        if (x != y) fa[x] = y, res += e.v;
    }
    return res;
}
```



## Prim算法

Kurskal 基于边，而 Prim 基于点：维护两个集合 $S,T$，$S$ 开始扔进去一号点，其他点放在 $T$ 里面，然后不停把 $T$ 里面距离 $S$ 最近的元素扔进去，直到 $T$ 为空。

算法复杂度为 $O(n^2)$，可以堆优化到 $O(m\log n)$，不过这种情况下不如直接 Kruskal 好。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5010;
int n, m, a[N][N], d[N];
bool vis[N];

void Prim() {
    memset(d, 0x3f, sizeof(d));
    memset(vis, 0, sizeof(vis));
    d[1] = 0;
    for (int i = 1; i < n; ++i) {
        int x = 0;
        for (int j = 1; j <= n; ++j)
            if (!vis[j] && (x == 0 || d[j] < d[x])) x = j;
        vis[x] = 1;
        for (int y = 1; y <= n; ++y)
            if (!vis[y]) d[y] = min(d[y], a[x][y]);
    }
}
int main()
{
    memset(a, 0x3f, sizeof(a));
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) a[i][i] = 0;
    for (int i = 1; i <= m; ++i) {
        int x, y, z;
        cin >> x >> y >> z;
        a[y][x] = a[x][y] = min(a[x][y], z);
    }
    Prim();
    //
    for (int i = 1; i <= n; ++i)
        if (d[i] == 0x3f3f3f3f) {
            puts("orz");
            return 0;
        }
    //
    int ans = 0;
    for (int i = 2; i <= n; ++i) ans += d[i];
    cout << ans;
    return 0;
}
```


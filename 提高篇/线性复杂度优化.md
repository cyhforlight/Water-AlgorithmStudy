# 线性复杂度优化

## 双指针算法

双指针算法（Two-pointer），又称尺取法，是一种序列上的常见算法优化技巧。

双指针分成两种：快慢指针和对撞指针，前者是两个指针同向移动，只是速度快慢，而后者则是相向而行。

双指针的用法相当灵活多变，能够结合很多算法共同使用。本教程中，我们重点关注前者在算法竞赛中的应用。（后者的一个经典应用就是快速排序中的 $O(n)$ 快速移数）

> [LeetCode 713. 乘积小于 K 的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/)
>
> 给定一个长度为 $n$ 的正整数数组 $\{a_n\}$ 和整数 $k$，求出该数组中乘积小于 $k$ 的连续子数组的个数。
>
> $n\leq 3*10^4,1\leq a_i\leq 10^3,0\leq k \leq 10^6$

我们不难构造出这样一个算法，$O(n^2)$ 枚举子数组，$O(n)$ 检查乘积，总复杂度 $O(n^3)$。可惜乘积太大，不然还能前缀和优化一下检查的部分。那么，这个算法能继续优化吗？

我们注意到，如果区间 $[l,r]$ 的乘积已经达到了 $k$，那么区间 $[l,r+1],[l,r+2],\cdots$ 全部不合法。同样的，$[l-1,r],[l-2,r],\cdots$ 也不合法。那么，我们比起枚举所有区间，不妨用两个指针 $l,r$ 表示区间左右端点，并进行如下流程：

1.  初始化 $l=1,r=0$
2. 将 $r$ 向右移动一格
3. 不断增加 $l$，直到 $[l,r]$ 内的积小于 $k$
4. 答案加上 $r-l+1$
5. 回到步骤2

过程中，左右端点均只增加了 $O(n)$ 次，因此总复杂度是 $O(n)$ 的。

```cpp
using LL = long long;
LL x = 1, ans = 0;
for (int r = 1, l = 1; r <= n; ++r) {
    x *= num[r];
    while (l <= i && x >= k) x /= a[l++];
    ans += r - l + 1;
}
```

## 单调栈与单调队列

### 单调栈

单调栈是一种特殊的栈，栈内部的数据是时刻有序的（跟优先队列不一样，它的数据有序是因为我们插入数据的时候人工保持了这个性质，数据结构本身和普通栈没有区别）。打个比方，我们将 $(1,4,2,8,5,7)$ 依次放入单调栈，则先后顺序为：

1. 插入 $1$，得 $[1]$
2. 插入 $4$，得 $[1,4]$
3. 为保持有序，插入 $2$ 前弹出 $4$，得 $[1, 2]$
4. 插入 $8$，得 $[1, 2,8]$
5. 为保持有序，插入 $5$ 前弹出 $8$，得 $[1, 2, 5]$
6. 插入 $7$，得 $[1,2,5,7]$

可以注意到，我们有意识的维护着整个栈的单调性。

单调栈有很多应用，其中一个较为出名的应用就是：

> [P5788 【模板】单调栈](https://www.luogu.com.cn/problem/P5788)
>
> 给定一个整数序列 $\{a_n\}$，定义 $f(i)$ 为数列第 $i$ 个元素后第一个大于 $a_i$ 的元素的下标（不存在则为0），请尝试求出 $f(1\cdots n)$ 的值。
>
> $n\leq 3*10^6,1\leq a_i\leq 10^9$

我们尝试模拟单调栈的流程，维护一个（对应元素值）单调递减的栈。

如果想要加入的新元素比栈顶指向的元素大，那么说明它遇到了第一个比它大的数，更新它的 $f$ 值，并将其从栈顶弹出，随后反复这一流程，直到新元素加入后满足单调栈的性质。

这一特性往往还被用于RMQ问题中，有时候效果很好。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3000010;
int n, a[N], f[N];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    //solve
    stack<int> s;
    for (int i = 1; i <= n; ++i) {
        while (!s.empty() && a[s.top()] < a[i]) {
            int x = s.top(); s.pop();
            f[x] = i;
        }
        s.push(i);
    }
    for (int i = 1; i <= n; ++i) printf("%d ", f[i]);
    return 0;
}
```

### 单调队列

同样的，单调队列也是一个维护队列有序性的结构，但是它可以同时在队头和队尾进行操作。

我们来看这样一个问题：

> [P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)
>
> 给定一个数列 $\{a_n\}$，请分别求出区间 $[1,k],[2,k+1],\cdots,[n - k+1,n]$ 上的最大值和最小值。
>
> $1\leq k\leq n\leq 10^6$，$a_i$ 在 int 范围内

我们尝试使用队列的思维，将数放入队列中，每放入一个数就考虑要不要从队头弹掉一个，但是问题在于，怎么从数列中找出最大值来？

我们举个例子，假设数列的前四项分别是 $6,5,1,4$，队列依次加入了前三项（此时队列为 $[6,5,1]$），并且考虑要不要加入第四项：

我们注意到，队列末尾的 $1$ 要比 $4$ 更早进入队列，且值更小，这意味着：

1. 更早进入队列：从该数字进入队列开始，后面的每个对应区间，只要前一个数存在，后一个数都会存在
2. 值更小：结合上一点，我们可以得到结论：它永远不可能成为后面某个区间的最大值

结合上面两点，我们可以考虑：如果新加入的数要比队尾更大，就弹掉那个队尾元素，直到该情形不成立/队列为空，再把这个数加进去。那么，这个队列内部的元素就是单调递减的，即单调递减队列。此时区间的最大值就对应队头元素。

单独从这个角度考虑，它似乎和单调栈/前缀最大值挺像，但是队列还需要时不时把队头元素弹出去（到期了，超过窗口范围了），因此他被称为单调队列。在实际代码中，我们通常使用 deque 来实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1000010;
int n, k, a[N], h[N], g[N];
void solve1() {
    deque<int> q;
    for (int i = 1; i <= n; ++i) {
        while (!q.empty() && q.front() < i - k + 1) q.pop_front();
        while (!q.empty() && a[q.back()] >= a[i]) q.pop_back();
        q.push_back(i);
        if (i >= k) printf("%d ", a[q.front()]);
    }
    puts("");
}
void solve2() {
    deque<int> q;
    for (int i = 1; i <= n; ++i) {
        while (!q.empty() && q.front() < i - k + 1) q.pop_front();
        while (!q.empty() && a[q.back()] <= a[i]) q.pop_back();
        q.push_back(i);
        if (i >= k) printf("%d ", a[q.front()]);
    }
    puts("");
}
int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    solve1(), solve2();
    return 0;
}
```

